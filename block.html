<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Puzzle Mirul Maker</title>
    <style>
        :root {
    --grid-size: 8;
    --cell-size-desktop: 50px; /* Base cell size for desktop */
    --grid-width-desktop: calc(var(--grid-size) * var(--cell-size-desktop));
    
    /* Light Theme Colors */
    --bg-color: #e8f0f2; /* Light blue-gray background */
    --text-color: #333;
    --grid-bg: #fff;
    --grid-border: #a7d9e2; /* Softer grid border */
    --grid-lines-major: #b0dbe4;
    --grid-lines-minor: #e0f2f7;
    --invalid-placement-color: #F00;
    --button-bg: #4CAF50; /* Green button */
    --button-text: #ffffff; /* White text */
}

.dark-theme {
    /* Dark Theme Colors */
    --bg-color: #37474f; /* Dark blue-gray background */
    --text-color: #f0f0f0;
    --grid-bg: #546e7a; /* Darker grid background */
    --grid-border: #78909c; /* Lighter grid border */
    --grid-lines-major: #607d8b;
    --grid-lines-minor: #455a64;
    --invalid-placement-color: #F00;
    --button-bg: #66bb6a; /* Green button for dark theme */
    --button-text: #ffffff; /* White text */
}

body {
    font-family: 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
    padding: 10px; /* Add some padding for mobile */
    box-sizing: border-box; /* Include padding in element's total width and height */
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: var(--grid-width-desktop); /* Use desktop width as base */
    max-width: 90vw; /* Max width for responsiveness */
    margin-bottom: 25px; /* Increased margin for more breathing room */
}

.volume-control {
    display: flex;
    align-items: center;
    margin-right: 20px;
    color: var(--text-color);
}

#volume-slider {
    cursor: pointer;
}

h1 {
    font-size: 2.5em; /* Slightly larger for prominence */
    color: var(--text-color); /* Ensure title color adapts to theme */
}

#theme-switcher {
    padding: 10px 15px; /* Slightly more padding */
    border: none; /* Remove border, rely on background and shadow */
    border-radius: 20px; /* More rounded corners */
    background-color: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    font-size: 1em; /* Consistent font size */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
}

#theme-switcher:hover {
    transform: translateY(-2px); /* Lift effect on hover */
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15); /* Enhanced shadow on hover */
}

#theme-switcher:active {
    transform: translateY(0); /* Press down effect on click */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.game-container {
    display: flex; /* Use flexbox for layout */
    flex-direction: column; /* Default to column for mobile */
    align-items: center;
    gap: 20px;
    max-width: 100%;
}

.score-container, .high-score-container {
    font-size: 1.8em; /* Slightly larger for prominence */
    margin-bottom: 15px; /* More spacing */
    white-space: nowrap; /* Keep score on one line */
    padding: 10px 20px; /* Add padding */
    border-radius: 15px; /* Rounded corners */
    /* Glassmorphism styles */
    background-color: rgba(255, 255, 255, 0.15); /* Semi-transparent background */
    backdrop-filter: blur(10px); /* Frosted glass effect */
    border: 1px solid rgba(255, 255,255, 0.2); /* Light, semi-transparent border */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08); /* Enhanced shadow */
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
    text-align: center; /* Center text for better look with progress bar */
}

/* Dark theme specific glassmorphism adjustments */
.dark-theme .score-container, .dark-theme .high-score-container {
    background-color: rgba(0, 0, 0, 0.2); /* Darker semi-transparent background */
    border: 1px solid rgba(255, 255,255, 0.1); /* Subtler border in dark mode */
}

.progress-bar-container {
    width: 100%;
    background-color: var(--grid-lines-minor);
    border-radius: 10px;
    margin-top: 10px;
    height: 15px;
    border: 1px solid var(--grid-lines-major);
    overflow: hidden; /* Ensures the inner bar stays within the rounded corners */
}

#progress-bar {
    width: 0%;
    height: 100%;
    background-color: var(--button-bg);
    border-radius: 10px 0 0 10px; /* Rounded corners only on the left */
    transition: width 0.5s ease-out; /* Smooth transition for width changes */
}

#gameGrid {
    border: 2px solid var(--grid-border);
    background-color: var(--grid-bg);
    width: calc(100vw - 40px); /* Adjust for padding, will be overridden by JS */
    height: calc(100vw - 40px); /* Adjust for padding, will be overridden by JS */
    max-width: var(--grid-width-desktop); /* Limit desktop size */
    max-height: var(--grid-width-desktop); /* Limit desktop size */
    box-sizing: border-box;
}

#block-container {
    display: flex;
    justify-content: center;
    flex-wrap: wrap; /* Allow blocks to wrap on smaller screens */
    gap: 20px; /* Increased gap for better separation */
    margin-top: 20px; /* More spacing from game grid */
    padding: 20px; /* Increased padding */
    border: none; /* Remove border, rely on background and shadow */
    background-color: var(--grid-bg);
    border-radius: 15px; /* More rounded corners */
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1); /* More pronounced shadow */
    transition: background-color 0.3s, box-shadow 0.3s;
}

.block {
    display: grid;
    cursor: grab;
    touch-action: none;
    transition: transform 0.1s ease-out; /* Smooth feedback on grab */
}

.block:active {
    transform: scale(1.05); /* Slight lift on active/grab */
}

/* Media Queries for Desktop */
@media (min-width: 768px) {
    .game-container {
        flex-direction: row; /* Row layout for desktop */
        align-items: flex-start; /* Align items to the top */
    }

    .header {
        width: var(--grid-width-desktop);
    }

    #gameGrid {
        width: var(--grid-width-desktop);
        height: var(--grid-width-desktop);
    }

    #block-container {
        flex-direction: column; /* Stack blocks vertically on desktop */
        height: auto; /* Allow height to adjust */
        padding: 25px; /* Increased padding for desktop */
        gap: 25px; /* Increased gap for desktop */
    }
    
    .score-container, .high-score-container {
        font-size: 1.8em; /* Consistent desktop font size */
        margin-bottom: 15px;
    }

    .block-cell {
        width: 25px; /* Base size for preview blocks */
        height: 25px;
        border-radius: 5px; /* Slightly more rounded */
        box-shadow: inset 0px 0px 5px rgba(0, 0, 0, 0.1); /* Softer inner shadow */
    }
}

/* Small screen adjustments */
@media (max-width: 480px) {
    h1 {
        font-size: 1.8em; /* Adjusted for small screens */
    }
    #theme-switcher {
        font-size: 0.9em;
        padding: 8px 12px;
    }
    .score-container, .high-score-container {
        font-size: 1.4em; /* Adjusted for small screens */
        padding: 8px 15px;
    }
}
    </style>
</head>
<body>
    <div class="header">
        <h1>Block Puzzle Mirul Maker</h1>
        <div class="volume-control">
            <label for="volume-slider">Volume:</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
        </div>
        <button id="theme-switcher">Toggle Theme</button>
    </div>
    <div class="game-container">
        <div class="score-container">
            Score: <span id="score">0</span>
            <div class="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
        </div>
        <div class="high-score-container">
            Highest Score: <span id="high-score">0</span>
        </div>
        <canvas id="gameGrid" width="400" height="400"></canvas>
        <div id="block-container">
            <!-- Available blocks will be generated here by JS -->
        </div>
        <audio id="game-over-music" src="music/game-over.mp3"></audio>
        <audio id="background-music" loop src="music/game-music-loop-6-144641.mp3"></audio>
        <audio id="line-clear-sound" src="music/power-up-sparkle.mp3"></audio>
        <audio id="power-up-sound" src="music/power-up-sparkle.mp3"></audio>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gameGrid');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('high-score'); // New element
    const progressBar = document.getElementById('progress-bar'); // Progress bar element
    const blockContainer = document.getElementById('block-container');
    const themeSwitcher = document.getElementById('theme-switcher');
    const body = document.body;
    const gameOverMusic = document.getElementById('game-over-music');
    const backgroundMusic = document.getElementById('background-music');
    const lineClearSound = document.getElementById('line-clear-sound');
    const powerUpSound = document.getElementById('power-up-sound');
    const volumeSlider = document.getElementById('volume-slider');

    function setVolume(volume) {
        backgroundMusic.volume = volume;
        lineClearSound.volume = volume;
        powerUpSound.volume = volume;
        gameOverMusic.volume = volume;
    }

    volumeSlider.addEventListener('input', (e) => {
        setVolume(e.target.value);
    });

    const GRID_SIZE = 8;
    // CELL_SIZE will be calculated dynamically
    let CELL_SIZE; 
    const PREVIEW_CELL_SIZE_BASE = 25; // Base size, can be adjusted for responsiveness
    let PREVIEW_CELL_SIZE = PREVIEW_CELL_SIZE_BASE;

    const POP_ANIMATION_DURATION = 300; // milliseconds

    let score = 0;
    let highScore = 0; // New high score variable
    let grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
    let isGameOver = false;
    let poppingCells = []; // Stores cells currently in pop animation

    // Added more colors for new blocks
    const COLORS = ['#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#9E22FF', '#FF00A0', '#00FFFF', '#FFD700', '#FF4500']; 
    const SHAPES = [
        { name: '1x1', shape: [[1]], color: COLORS[0] },
        { name: '1x2', shape: [[1, 1]], color: COLORS[1] },
        { name: '2x1', shape: [[1], [1]], color: COLORS[1] },
        { name: '1x3', shape: [[1, 1, 1]], color: COLORS[2] },
        { name: '3x1', shape: [[1], [1], [1]], color: COLORS[2] },
        { name: '2x2', shape: [[1, 1], [1, 1]], color: COLORS[3] },
        { name: 'S', shape: [[0, 1, 1], [1, 1, 0]], color: COLORS[4] },
        { name: 'Z', shape: [[1, 1, 0], [0, 1, 1]], color: COLORS[4] },
        { name: 'T', shape: [[1, 1, 1], [0, 1, 0]], color: COLORS[5] },
        { name: 'L', shape: [[1, 0], [1, 0], [1, 1]], color: COLORS[6] },
        { name: 'J', shape: [[0, 1], [0, 1], [1, 1]], color: COLORS[6] },
        { name: '3x3', shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], color: COLORS[7] },
        { name: '3x1_new', shape: [[1, 1, 1]], color: COLORS[8] }, // New 3x1 block (horizontal)
        { name: '4x1_new', shape: [[1, 1, 1, 1]], color: COLORS[9] }, // New 4x1 block (horizontal)
        { name: '5x1_new', shape: [[1, 1, 1, 1, 1]], color: COLORS[10] }, // New 5x1 block (horizontal)
        { name: '1x3_new', shape: [[1], [1], [1]], color: COLORS[8] }, // New 3x1 block (vertical)
        { name: '1x4_new', shape: [[1], [1], [1], [1]], color: COLORS[9] }, // New 4x1 block (vertical)
        { name: '1x5_new', shape: [[1], [1], [1], [1], [1]], color: COLORS[10] }, // New 5x1 block (vertical)
    ];

    let draggedBlock = null;
    let ghostBlock = null;
    let draggedBlockInfo = null; // Will hold { shape, color, target }
    let isDragging = false; // Added back for native touch events
    let currentMessage = null; // {text: "msg", color: "col", startTime: Date.now()}

    // --- Utilities ---
    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    // --- Theme Switching ---
    themeSwitcher.addEventListener('click', () => {
        body.classList.toggle('dark-theme');
        adjustCanvasAndCellSizes(); // Recalculate sizes on theme change as well
        draw(); // Redraw canvas with new theme colors
    });

    function getCssVariable(variable) {
        return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
    }

    // Helper to adjust color for 3D effect
    function adjustColor(hex, percent) {
        let f = parseInt(hex.slice(1), 16),
            t = percent < 0 ? 0 : 255,
            p = percent < 0 ? percent * -1 : percent,
            R = f >> 16,
            G = (f >> 8) & 0x00ff,
            B = (f >> 8) & 0x0000ff;
        return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
    }

    // Helper to get coordinates from mouse or touch events
    function getEventCoords(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    // Easing function for smoother animations (ease-out quad)
    function easeOutQuad(t) {
        return t * (2 - t);
    }

    // --- Responsive Sizing ---
    function adjustCanvasAndCellSizes() {
        // Get the computed width from CSS after layout, ensuring responsiveness
        const computedStyle = getComputedStyle(canvas);
        const desiredCanvasWidth = parseFloat(computedStyle.width);
        
        canvas.width = desiredCanvasWidth;
        canvas.height = desiredCanvasWidth; // Keep it square

        CELL_SIZE = canvas.width / GRID_SIZE;

        // Adjust PREVIEW_CELL_SIZE dynamically if needed, or keep fixed
        // For now, it remains fixed but can be scaled if preview blocks also need to be very responsive
        // PREVIEW_CELL_SIZE = CELL_SIZE / 2; // Example for dynamic scaling
        
        // Re-render blocks in container to adjust to new PREVIEW_CELL_SIZE if it were dynamic
        // generateAvailableBlocks() would need to be called, but doing so would reset the player's choices
        // For now, only adjust if PREVIEW_CELL_SIZE itself becomes dynamic.
        updateBlockContainerElements(); // Updates styles based on PREVIEW_CELL_SIZE
    }

    // This function updates the block elements in the container with potentially new PREVIEW_CELL_SIZE
    function updateBlockContainerElements() {
        Array.from(blockContainer.children).forEach(blockEl => {
            const shape = JSON.parse(blockEl.dataset.shape);
            blockEl.style.gridTemplateRows = `repeat(${shape.length}, ${PREVIEW_CELL_SIZE}px)`;
            blockEl.style.gridTemplateColumns = `repeat(${shape[0].length}, ${PREVIEW_CELL_SIZE}px)`;
            
            // Re-apply background colors to block-cells within blockElement
            const cells = blockEl.querySelectorAll('.block-cell');
            cells.forEach(cellDiv => {
                cellDiv.style.backgroundColor = blockEl.dataset.color; // Ensure color is set, good for theme changes
            });
        });
    }

    window.addEventListener('resize', () => {
        adjustCanvasAndCellSizes();
        draw();
    });

    // --- Block Generation & Display ---
    function generateAvailableBlocks() {
        blockContainer.innerHTML = ''; // Clear existing blocks
        for (let i = 0; i < 3; i++) {
            const blockInfo = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const blockElement = createBlockElement(blockInfo);
            blockContainer.appendChild(blockElement);
        }
        // Removed checkGameOver() call from here
    }

    function createBlockElement(blockInfo) {
        const blockElement = document.createElement('div');
        blockElement.classList.add('block');
        blockElement.style.gridTemplateRows = `repeat(${blockInfo.shape.length}, ${PREVIEW_CELL_SIZE}px)`;
        blockElement.style.gridTemplateColumns = `repeat(${blockInfo.shape[0].length}, ${PREVIEW_CELL_SIZE}px)`;
        
        // Interact.js will handle the draggable property, so setting blockElement.draggable = true is not needed.

        blockInfo.shape.forEach(row => {
            row.forEach(cell => {
                const cellDiv = document.createElement('div');
                if (cell) {
                    cellDiv.classList.add('block-cell');
                    cellDiv.style.backgroundColor = blockInfo.color;
                }
                blockElement.appendChild(cellDiv);
            });
        });

        blockElement.dataset.shape = JSON.stringify(blockInfo.shape);
        blockElement.dataset.color = blockInfo.color;

        // Set initial position for Interact.js to use for snapping back
        blockElement.dataset.x = 0;
        blockElement.dataset.y = 0;
        
        return blockElement;
    }

    // --- Interact.js Drag and Drop Logic ---

    function setupInteract() {
        // --- Throttled Ghost Block Update ---
        const handleDragMove = (event) => {
            if (isGameOver || !draggedBlockInfo) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            const x = event.dragEvent.client.x - canvasRect.left;
            const y = event.dragEvent.client.y - canvasRect.top;

            const gridX = Math.floor(x / CELL_SIZE);
            const gridY = Math.floor(y / CELL_SIZE);

            // Reuse the ghostBlock object instead of creating a new one
            if (!ghostBlock) ghostBlock = {};
            ghostBlock.shape = draggedBlockInfo.shape;
            ghostBlock.color = draggedBlockInfo.color;
            ghostBlock.x = gridX;
            ghostBlock.y = gridY;
            // Do NOT call draw() here. The rAF loop will handle it.
        }
        const throttledDragMove = throttle(handleDragMove, 50); // Limit to 20fps

        interact('.block').draggable({
            inertia: true,
            autoScroll: true,
            listeners: {
                start (event) {
                    if (isGameOver) return;
                    const target = event.target;
                    // Pre-parse and cache block info to avoid doing it on every move
                    draggedBlockInfo = {
                        shape: JSON.parse(target.dataset.shape),
                        color: target.dataset.color,
                        target: target
                    };
                    // Keep the dragged block on top
                    target.style.zIndex = 1000;
                },
                move (event) {
                    if (isGameOver) return;
                    const target = event.target;
                    // keep the dragged position in the data-x/data-y attributes
                    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                    // translate the element
                    target.style.transform = `translate(${x}px, ${y}px)`;

                    // update the posiion attributes
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                end (event) {
                    if (isGameOver) return;
                    // Animate back to original position if not dropped
                    if (!event.relatedTarget) { // relatedTarget is the dropzone
                        draggedBlockInfo.target.style.transition = 'transform 0.5s ease-in-out';
                        draggedBlockInfo.target.style.transform = 'translate(0px, 0px)';
                        draggedBlockInfo.target.setAttribute('data-x', 0);
                        draggedBlockInfo.target.setAttribute('data-y', 0);
                        setTimeout(() => {
                            draggedBlockInfo.target.style.transition = ''; // Remove transition after animation
                        }, 500);
                    }
                    // Clean up state
                    draggedBlockInfo.target.style.zIndex = '';
                    ghostBlock = null;
                    draggedBlockInfo = null;
                    // Do NOT call draw() here.
                }
            }
        });

        interact('#gameGrid').dropzone({
            accept: '.block',
            ondragenter: throttledDragMove,
            ondragleave: function (event) {
                if (isGameOver) return;
                ghostBlock = null;
                // Do NOT call draw() here.
            },
            ondrop: function (event) {
                if (isGameOver || !draggedBlockInfo) return;
                
                const canvasRect = canvas.getBoundingClientRect();
                const dropX = event.dragEvent.client.x - canvasRect.left;
                const dropY = event.dragEvent.client.y - canvasRect.top;

                const gridX = Math.floor(dropX / CELL_SIZE);
                const gridY = Math.floor(dropY / CELL_SIZE);

                // Use the cached info from draggedBlockInfo
                const finalGhostBlock = { 
                    shape: draggedBlockInfo.shape, 
                    color: draggedBlockInfo.color, 
                    x: gridX, 
                    y: gridY 
                };

                if (isValidPlacement(finalGhostBlock)) {
                    placeBlock(finalGhostBlock);
                    draggedBlockInfo.target.remove(); // Use the cached target
                    if (blockContainer.children.length === 0) {
                        generateAvailableBlocks();
                    }
                    clearLines();
                    checkGameOver();
                } else {
                    displayMessage('Invalid placement!', 'red', 1000);
                    // Snap back animation
                    draggedBlockInfo.target.style.transition = 'transform 0.5s ease-in-out';
                    draggedBlockInfo.target.style.transform = 'translate(0px, 0px)';
                    draggedBlockInfo.target.setAttribute('data-x', 0);
                    draggedBlockInfo.target.setAttribute('data-y', 0);
                    setTimeout(() => {
                        draggedBlockInfo.target.style.transition = '';
                    }, 500);
                }
                // Do NOT call draw() here. State is already clean.
            },
            ondropmove: throttledDragMove
        });
    }
    
    
    // --- Game Logic ---
    function isValidPlacement(block, checkGrid = grid) {
        const { shape, x, y } = block;
        // console.log(`  isValidPlacement called for block at (${x},${y}) with shape:`, shape); // Uncomment if too verbose
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
                if (shape[r][c]) {
                    const gridR = y + r;
                    const gridC = x + c;
                    if (gridR < 0 || gridR >= GRID_SIZE || gridC < 0 || gridC >= GRID_SIZE) {
                        // console.log(`    Invalid: Out of bounds at (${gridC},${gridR}) for block starting at (${x},${y})`);
                        return false;
                    }
                    if (checkGrid[gridR][gridC]) {
                        // console.log(`    Invalid: Overlap at (${gridC},${gridR}) for block starting at (${x},${y})`);
                        return false;
                    }
                }
            }
        }
        // console.log(`  Valid placement for block starting at (${x},${y})`);
        return true;
    }

    function placeBlock(block) {
        const { shape, color, x, y } = block;
        let blocksPlaced = 0;
        shape.forEach((row, r) => {
            row.forEach((cell, c) => {
                if (cell) {
                    grid[y + r][x + c] = color;
                    blocksPlaced++;
                }
            });
        });
        score += blocksPlaced; // Each placed block cell contributes to score
        updateScore();
    }
    
    function clearLines() {
        let cellsClearedCount = 0;
        let cellsToClear = new Set(); // To store unique "r,c" coordinates
        let rowsCleared = 0;
        let colsCleared = 0;

        // Check for full rows
        for(let r = 0; r < GRID_SIZE; r++) {
            if (grid[r].every(cell => cell !== null)) {
                rowsCleared++;
                for(let c = 0; c < GRID_SIZE; c++) {
                    cellsToClear.add(`${r},${c}`);
                }
            }
        }

        // Check for full columns
        for(let c = 0; c < GRID_SIZE; c++) {
            let colFull = true;
            for(let r = 0; r < GRID_SIZE; r++) {
                if (grid[r][c] === null) {
                    colFull = false;
                    break;
                }
            }
            if (colFull) {
                colsCleared++;
                for(let r = 0; r < GRID_SIZE; r++) {
                    cellsToClear.add(`${r},${c}`);
                }
            }
        }
        
        // Mark cells for popping animation
        if (cellsToClear.size > 0) {
            lineClearSound.play();
            const animationStartTime = Date.now();
            cellsToClear.forEach(coords => {
                const [r, c] = coords.split(',').map(Number);
                poppingCells.push({ r, c, color: grid[r][c], startTime: animationStartTime });
            });

            setTimeout(() => {
                cellsToClear.forEach(coords => {
                    const [r, c] = coords.split(',').map(Number);
                    grid[r][c] = null;
                });
                cellsClearedCount = cellsToClear.size;
                poppingCells = []; // Clear popping cells after animation

                let combo = rowsCleared + colsCleared;
                let scoreToAdd = cellsClearedCount * 20;
                if (combo >= 2) {
                    scoreToAdd *= Math.pow(2, combo - 1);
                    powerUpSound.play();
                }
                score += scoreToAdd;
                
                updateScore();
                draw(); // Final redraw after cells are null

                // Combo and encouragement messages
                if (rowsCleared + colsCleared > 1) {
                    displayMessage(`Combo x${rowsCleared + colsCleared}! Amazing!`, 'green');
                } else if (rowsCleared + colsCleared === 1) {
                    displayMessage('Good Clear!', 'blue');
                }
            }, POP_ANIMATION_DURATION);
        }
    }
    
    let messageTimeout;
    function displayMessage(msg, color = 'white', duration = 1500) {
        currentMessage = { text: msg, color: color, startTime: Date.now(), duration: duration };
        // We don't call draw() here, it's called by requestAnimationFrame in the main loop
    }


    function checkGameOver() {
        console.log("--- checkGameOver() called ---");
        let availableBlocks = Array.from(blockContainer.children);
        console.log(`Available blocks in container: ${availableBlocks.length}`);

        // Helper function to check if any block can be placed
        const canAnyBlockBePlaced = (blocksToCheck) => {
            console.log("  canAnyBlockBePlaced() called.");
            if (blocksToCheck.length === 0) {
                console.log("    No blocks to check. Returning false.");
                return false;
            }
            for (const blockEl of blocksToCheck) {
                const shape = JSON.parse(blockEl.dataset.shape);
                const color = blockEl.dataset.color; 
                console.log(`    Testing block with shape:`, shape);
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const tempBlock = { shape, color, x: c, y: r };
                        if (isValidPlacement(tempBlock)) {
                            console.log(`      Block can be placed at (${c}, ${r}). Returning true.`);
                            return true;
                        }
                    }
                }
            }
            console.log("  No block can be placed anywhere. Returning false.");
            return false;
        };

        let anyBlockCanBePlacedNow = canAnyBlockBePlaced(availableBlocks);

        if (availableBlocks.length === 0) {
            console.log("All blocks placed. Generating new ones.");
            generateAvailableBlocks();
            availableBlocks = Array.from(blockContainer.children); 
            anyBlockCanBePlacedNow = canAnyBlockBePlaced(availableBlocks); 
        }

        if (!anyBlockCanBePlacedNow) {
            console.log("No valid placements found for any available block. GAME OVER.");
            isGameOver = true;
            gameOverMusic.play();
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('blockPuzzleHighScore', highScore);
                updateHighScoreDisplay();
            }
        } else {
            console.log("Valid placements still possible. Game continues.");
            isGameOver = false;
        }
    }
    
    function updateScore() {
        scoreEl.textContent = score;
        updateProgressBar();
    }

    function updateHighScoreDisplay() {
        highScoreEl.textContent = highScore;
        updateProgressBar();
    }

    function updateProgressBar() {
        if (!progressBar) return;
        let percentage = 0;
        if (highScore > 0) {
            percentage = (score / highScore) * 100;
        } else if (score > 0) {
            percentage = 100; // If there's a score but no high score yet, fill the bar
        }
        
        percentage = Math.min(100, percentage); // Cap at 100%
        progressBar.style.width = `${percentage}%`;
    }

    // --- Drawing Functions ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackgroundGrid(); // Draw grid background
        drawGridLines();
        drawPlacedBlocks();
        drawPoppingCells(); // Draw cells currently popping
        if (ghostBlock) {
            drawGhostBlock();
        }

        if (isGameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 10);
            ctx.font = '16px Arial';
            ctx.fillText('Click to Restart', canvas.width / 2, canvas.height / 2 + 20);
        } else if (currentMessage) {
            const elapsed = Date.now() - currentMessage.startTime;
            if (elapsed < currentMessage.duration) {
                const alpha = 1 - (elapsed / currentMessage.duration);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = currentMessage.color;
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentMessage.text, canvas.width / 2, canvas.height / 2 + 50);
                ctx.globalAlpha = 1.0;
            } else {
                currentMessage = null; // Clear message after duration
            }
        }
        requestAnimationFrame(draw); // Keep the main draw loop running
    }

    function drawBackgroundGrid() {
        ctx.fillStyle = getCssVariable('--grid-bg');
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawGridLines() {
        // Draw major grid lines
        ctx.strokeStyle = getCssVariable('--grid-lines-major');
        ctx.lineWidth = 2; 
        for (let i = 0; i <= GRID_SIZE; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE, 0);
            ctx.lineTo(i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i * CELL_SIZE);
            ctx.lineTo(GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
            ctx.stroke();
        }

        // Draw minor grid lines (cell separators)
        ctx.strokeStyle = getCssVariable('--grid-lines-minor');
        ctx.lineWidth = 1;
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                ctx.beginPath();
                ctx.moveTo(c * CELL_SIZE + CELL_SIZE, r * CELL_SIZE);
                ctx.lineTo(c * CELL_SIZE + CELL_SIZE, (r + 1) * CELL_SIZE);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(c * CELL_SIZE, r * CELL_SIZE + CELL_SIZE);
                ctx.lineTo((c + 1) * CELL_SIZE, r * CELL_SIZE + CELL_SIZE);
                ctx.stroke();
            }
        }
    }
    
    // Function to draw a single cell with 3D effect
    function drawBlockCell(x, y, color, alpha = 1.0) {
        ctx.globalAlpha = alpha;
        
        // Main face
        ctx.fillStyle = color;
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);

        // Highlights (top and left)
        ctx.fillStyle = adjustColor(color, 0.2); // Lighter
        ctx.fillRect(x, y, CELL_SIZE, 2); // Top highlight
        ctx.fillRect(x, y, 2, CELL_SIZE); // Left highlight

        // Shadows (bottom and right)
        ctx.fillStyle = adjustColor(color, -0.2); // Darker
        ctx.fillRect(x, y + CELL_SIZE - 2, CELL_SIZE, 2); // Bottom shadow
        ctx.fillRect(x + CELL_SIZE - 2, y, 2, CELL_SIZE); // Right shadow

        // Shiny effect: a small transparent white rectangle
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; // White with transparency
        ctx.fillRect(x + 2, y + 2, CELL_SIZE / 3, CELL_SIZE / 3); // Top-left shine
        
        ctx.globalAlpha = 1.0;
    }


    function drawPlacedBlocks() {
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (grid[r][c]) {
                    drawBlockCell(c * CELL_SIZE, r * CELL_SIZE, grid[r][c]);
                }
            }
        }
    }
    
    function drawPoppingCells() {
        const currentTime = Date.now();
        poppingCells.forEach(cell => {
            const elapsed = currentTime - cell.startTime;
            const progress = elapsed / POP_ANIMATION_DURATION;
            
            if (progress < 1) {
                const easedProgress = easeOutQuad(progress); // Apply easing
                const alpha = 1 - easedProgress; // Fade out with easing
                const scale = 1 - easedProgress * 0.5; // Shrink slightly with easing

                const drawSize = CELL_SIZE * scale;
                const offset = (CELL_SIZE - drawSize) / 2;

                drawBlockCell(cell.c * CELL_SIZE + offset, cell.r * CELL_SIZE + offset, cell.color, alpha);
            }
        });
        // Important: requestAnimationFrame(draw) is now in the main draw loop
        // If poppingCells is not empty, ensure draw() is called again.
        // This is handled by the main requestAnimationFrame(draw) at the end of draw().
    }

    function drawGhostBlock() {
        const { shape, color, x, y } = ghostBlock;
        const isValid = isValidPlacement(ghostBlock);
        // Use the block's color, or a specific invalid color
        const ghostColor = isValid ? color : getCssVariable('--invalid-placement-color');

        shape.forEach((row, r) => {
            row.forEach((cell, c) => {
                if (cell) {
                    // Draw ghost cells with transparency and the determined color
                    drawBlockCell((x + c) * CELL_SIZE, (y + r) * CELL_SIZE, ghostColor, 0.5);
                }
            });
        });
    }

    // --- Init ---
    function init() {
        // Set initial theme to light if no preference
        if (!body.classList.contains('dark-theme')) {
            body.classList.add('light-theme');
        }
        adjustCanvasAndCellSizes(); // Initial sizing
        isGameOver = false; // Ensure game is not over on init
        
        // Load high score
        highScore = parseInt(localStorage.getItem('blockPuzzleHighScore') || '0');
        updateHighScoreDisplay();
        updateProgressBar();

        setVolume(volumeSlider.value);
        body.addEventListener('click', () => {
            backgroundMusic.play().catch(error => {
                console.error("Background music couldn't play:", error);
            });
        }, { once: true });

        draw();
        generateAvailableBlocks();
        setupInteract(); // Initialize Interact.js
    }

    // Restart game listener
    canvas.addEventListener('click', () => {
        if (isGameOver) {
            score = 0;
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
            isGameOver = false;
            currentMessage = null; // Clear any lingering messages
            generateAvailableBlocks();
            updateScore();
            updateProgressBar();
            // No need to call draw() here, requestAnimationFrame will pick it up
        }
    });

    init();
});
    </script>
</body>
</html>
